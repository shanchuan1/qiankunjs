/*
 * @Author: zhongqifeng 1121021693@qq.com
 * @Date: 2024-02-26 18:48:45
 * @LastEditors: zhongqifeng 1121021693@qq.com
 * @LastEditTime: 2024-02-27 16:46:04
 * @FilePath: \qiankun-vue-demo\main\src\qiankunApi\sandbox\pathers\dynamicAppend\common.js
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 */
import { execScripts } from 'import-html-entry';
import { isFunction } from 'lodash';
import { frameworkConfiguration } from '../../../apis';
import { qiankunHeadTagName } from '../../../utils';
import { cachedGlobals } from '../../proxySandbox';
import * as css from '../css';


const SCRIPT_TAG_NAME = 'SCRIPT';
const LINK_TAG_NAME = 'LINK';
const STYLE_TAG_NAME = 'STYLE';

export const styleElementTargetSymbol = Symbol('target');
export const styleElementRefNodeNo = Symbol('refNodeNo');
const overwrittenSymbol = Symbol('qiankun-overwritten');

export const getAppWrapperHeadElement = (appWrapper) => {
    return appWrapper.querySelector(qiankunHeadTagName);
};

export function isExecutableScriptType(script) {
    return (
        !script.type ||
        ['text/javascript', 'module', 'application/javascript', 'text/ecmascript', 'application/ecmascript'].indexOf(
            script.type,
        ) !== -1
    );
}

export function isHijackingTag(tagName) {
    return (
        tagName?.toUpperCase() === LINK_TAG_NAME ||
        tagName?.toUpperCase() === STYLE_TAG_NAME ||
        tagName?.toUpperCase() === SCRIPT_TAG_NAME
    );
}

/**
 * Check if a style element is a styled-component liked.
 * A styled-components liked element is which not have textContext but keep the rules in its styleSheet.cssRules.
 * Such as the style element generated by styled-components and emotion.
 * @param element
 */
export function isStyledComponentsLike(element) {
    return (
        !element.textContent &&
        ((element.sheet)?.cssRules.length || getStyledElementCSSRules(element)?.length)
    );
}

const appsCounterMap = new Map();

export function calcAppCount(
    appName,
    calcType,
    status,
) {
    const appCount = appsCounterMap.get(appName) || { bootstrappingPatchCount: 0, mountingPatchCount: 0 };
    switch (calcType) {
        case 'increase':
            appCount[`${status}PatchCount`] += 1;
            break;
        case 'decrease':
            // bootstrap patch just called once but its freer will be called multiple times
            if (appCount[`${status}PatchCount`] > 0) {
                appCount[`${status}PatchCount`] -= 1;
            }
            break;
    }
    appsCounterMap.set(appName, appCount);
}

export function isAllAppsUnmounted() {
    return Array.from(appsCounterMap.entries()).every(
        ([, { bootstrappingPatchCount: bpc, mountingPatchCount: mpc }]) => bpc === 0 && mpc === 0,
    );
}

function patchCustomEvent(
    e,
    elementGetter,
) {
    Object.defineProperties(e, {
        srcElement: {
            get: elementGetter,
        },
        target: {
            get: elementGetter,
        },
    });

    return e;
}


function manualInvokeElementOnLoad(element) {
    // we need to invoke the onload event manually to notify the event listener that the script was completed
    // here are the two typical ways of dynamic script loading
    // 1. element.onload callback way, which webpack and loadjs used, see https://github.com/muicss/loadjs/blob/master/src/loadjs.js#L138
    // 2. addEventListener way, which toast-loader used, see https://github.com/pyrsmk/toast/blob/master/src/Toast.ts#L64
    const loadEvent = new CustomEvent('load');
    const patchedEvent = patchCustomEvent(loadEvent, () => element);
    if (isFunction(element.onload)) {
        element.onload(patchedEvent);
    } else {
        element.dispatchEvent(patchedEvent);
    }
}

function manualInvokeElementOnError(getAppWrapperHeadElement) {
    const errorEvent = new CustomEvent('error');
    const patchedEvent = patchCustomEvent(errorEvent, () => element);
    if (isFunction(element.onerror)) {
        element.onerror(patchedEvent);
    } else {
        element.dispatchEvent(patchedEvent);
    }
}

function convertLinkAsStyle(
    element,
    postProcess,
    fetchFn = fetch,
) {
    const styleElement = document.createElement('style');
    const { href } = element;
    // add source link element href
    styleElement.dataset.qiankunHref = href;

    fetchFn(href)
        .then((res) => res.text())
        .then((styleContext) => {
            styleElement.appendChild(document.createTextNode(styleContext));
            postProcess(styleElement);
            manualInvokeElementOnLoad(element);
        })
        .catch(() => manualInvokeElementOnError(element));

    return styleElement;
}

const defineNonEnumerableProperty = (target, key, value) => {
    Object.defineProperty(target, key, {
        configurable: true,
        enumerable: false,
        writable: true,
        value,
    });
};



const styledComponentCSSRulesMap = new WeakMap();
const dynamicScriptAttachedCommentMap = new WeakMap();
const dynamicLinkAttachedInlineStyleMap = new WeakMap();


export function recordStyledComponentsCSSRules(styleElements) {
    styleElements.forEach((styleElement) => {
        /*
         With a styled-components generated style element, we need to record its cssRules for restore next re-mounting time.
         We're doing that because the sheet of style element is going to be cleaned automatically by browser after the style element dom removed from document.
         see https://www.w3.org/TR/cssom-1/#associated-css-style-sheet
         */
        if (styleElement instanceof HTMLStyleElement && isStyledComponentsLike(styleElement)) {
            if (styleElement.sheet) {
                // record the original css rules of the style element for restore
                styledComponentCSSRulesMap.set(styleElement, (styleElement.sheet).cssRules);
            }
        }
    });
}

export function getStyledElementCSSRules(styledElement) {
    return styledComponentCSSRulesMap.get(styledElement);
}


// function getOverwrittenAppendChildOrInsertBefore(opts) {
//     function appendChildOrInsertBefore(
//         _this,
//         newChild,
//         refChild = null,
//     ) {
//         let element = newChild
//         const { rawDOMAppendOrInsertBefore, isInvokedByMicroApp, containerConfigGetter, target = 'body' } = opts;
//         if (!isHijackingTag(element.tagName) || !isInvokedByMicroApp(element)) {
//             return rawDOMAppendOrInsertBefore.call(_this, element, refChild);
//         }

//         if (element.tagName) {
//             const containerConfig = containerConfigGetter(element);
//             const {
//                 appName,
//                 appWrapperGetter,
//                 proxy,
//                 strictGlobal,
//                 speedySandbox,
//                 dynamicStyleSheetElements,
//                 scopedCSS,
//                 excludeAssetFilter,
//             } = containerConfig;

//             switch (element.tagName) {
//                 case LINK_TAG_NAME:
//                 case STYLE_TAG_NAME: {
//                     let stylesheetElement = newChild;
//                     const { href } = stylesheetElement;
//                     if (excludeAssetFilter && href && excludeAssetFilter(href)) {
//                         return rawDOMAppendOrInsertBefore.call(_this, element, refChild)
//                     }

//                     defineNonEnumerableProperty(stylesheetElement, styleElementTargetSymbol, target);

//                     const appWrapper = appWrapperGetter();

//                     if (scopedCSS) {
//                         // exclude link elements like <link rel="icon" href="favicon.ico">
//                         const linkElementUsingStylesheet =
//                             element.tagName?.toUpperCase() === LINK_TAG_NAME &&
//                             (element).rel === 'stylesheet' &&
//                             (element).href;
//                         if (linkElementUsingStylesheet) {
//                             const fetch =
//                                 typeof frameworkConfiguration.fetch === 'function'
//                                     ? frameworkConfiguration.fetch
//                                     : frameworkConfiguration.fetch?.fn;
//                             stylesheetElement = convertLinkAsStyle(
//                                 element,
//                                 (styleElement) => css.process(appWrapper, styleElement, appName),
//                                 fetch,
//                             );
//                             dynamicLinkAttachedInlineStyleMap.set(element, stylesheetElement);
//                         } else {
//                             css.process(appWrapper, stylesheetElement, appName);
//                         }
//                     }

//                     const mountDOM = target === 'head' ? getAppWrapperHeadElement(appWrapper) : appWrapper;

//                     const referenceNode = mountDOM.contains(refChild) ? refChild : null;

//                     let refNo;
//                     if (referenceNode) {
//                         refNo = Array.from(mountDOM.childNodes).indexOf(referenceNode);
//                     }

//                     const result = rawDOMAppendOrInsertBefore.call(mountDOM, stylesheetElement, referenceNode);

//                     // record refNo thus we can keep order while remounting
//                     if (typeof refNo === 'number' && refNo !== -1) {
//                         defineNonEnumerableProperty(stylesheetElement, styleElementRefNodeNo, refNo);
//                     }
//                     // record dynamic style elements after insert succeed
//                     dynamicStyleSheetElements.push(stylesheetElement);

//                     return result;
//                 }

//                 case SCRIPT_TAG_NAME: {
//                     const { src, text } = element;
//                     // some script like jsonp maybe not support cors which shouldn't use execScripts
//                     if ((excludeAssetFilter && src && excludeAssetFilter(src)) || !isExecutableScriptType(element)) {
//                         return rawDOMAppendOrInsertBefore.call(that, element, refChild);
//                     }

//                     const appWrapper = appWrapperGetter();
//                     const mountDOM = target === 'head' ? getAppWrapperHeadElement(appWrapper) : appWrapper;

//                     const { fetch } = frameworkConfiguration;
//                     const referenceNode = mountDOM.contains(refChild) ? refChild : null;

//                     const scopedGlobalVariables = speedySandbox ? cachedGlobals : [];

//                     if (src) {
//                         let isRedfinedCurrentScript = false;
//                         execScripts(null, [src], proxy, {
//                             fetch,
//                             strictGlobal,
//                             scopedGlobalVariables,
//                             beforeExec: () => {
//                                 const isCurrentScriptConfigurable = () => {
//                                     const descriptor = Object.getOwnPropertyDescriptor(document, 'currentScript');
//                                     return !descriptor || descriptor.configurable;
//                                 };
//                                 if (isCurrentScriptConfigurable()) {
//                                     Object.defineProperty(document, 'currentScript', {
//                                         get() {
//                                             return element;
//                                         },
//                                         configurable: true,
//                                     });
//                                     isRedfinedCurrentScript = true;
//                                 }
//                             },
//                             success: () => {
//                                 manualInvokeElementOnLoad(element);
//                                 if (isRedfinedCurrentScript) {
//                                     // @ts-ignore
//                                     delete document.currentScript;
//                                 }
//                                 element = null;
//                             },
//                             error: () => {
//                                 manualInvokeElementOnError(element);
//                                 if (isRedfinedCurrentScript) {
//                                     // @ts-ignore
//                                     delete document.currentScript;
//                                 }
//                                 element = null;
//                             },
//                         });

//                         const dynamicScriptCommentElement = document.createComment(`dynamic script ${src} replaced by qiankun`);
//                         dynamicScriptAttachedCommentMap.set(element, dynamicScriptCommentElement);
//                         return rawDOMAppendOrInsertBefore.call(mountDOM, dynamicScriptCommentElement, referenceNode);
//                     }

//                     // inline script never trigger the onload and onerror event
//                     execScripts(null, [`<script>${text}</script>`], proxy, { strictGlobal, scopedGlobalVariables });
//                     const dynamicInlineScriptCommentElement = document.createComment('dynamic inline script replaced by qiankun');
//                     dynamicScriptAttachedCommentMap.set(element, dynamicInlineScriptCommentElement);
//                     return rawDOMAppendOrInsertBefore.call(mountDOM, dynamicInlineScriptCommentElement, referenceNode);
//                 }

//                 default:
//                     break;
//             }
//         }

//         return rawDOMAppendOrInsertBefore.call(_this, element, refChild);
//     }

//     appendChildOrInsertBefore[overwrittenSymbol] = true;

//     return appendChildOrInsertBefore;
// }

function getOverwrittenAppendChildOrInsertBefore(opts) {
    function appendChildOrInsertBefore(newChild, refChild = null) {
      let element = newChild;
      const { rawDOMAppendOrInsertBefore, isInvokedByMicroApp, containerConfigGetter, target = 'body' } = opts;
      if (!isHijackingTag(element.tagName) || !isInvokedByMicroApp(element)) {
        return rawDOMAppendOrInsertBefore.call(this, element, refChild);
      }
      if (element.tagName) {
        const containerConfig = containerConfigGetter(element);
        const { appName, appWrapperGetter, proxy, strictGlobal, speedySandbox, dynamicStyleSheetElements, scopedCSS, excludeAssetFilter } = containerConfig;
        switch (element.tagName) {
          case LINK_TAG_NAME:
          case STYLE_TAG_NAME: {
            let stylesheetElement = newChild;
            const { href } = stylesheetElement;
            if (excludeAssetFilter && href && excludeAssetFilter(href)) {
              return rawDOMAppendOrInsertBefore.call(this, element, refChild);
            }
            defineNonEnumerableProperty(stylesheetElement, styleElementTargetSymbol, target);
            const appWrapper = appWrapperGetter();
            if (scopedCSS) {
              const linkElementUsingStylesheet = element.tagName?.toUpperCase() === LINK_TAG_NAME && element.rel === 'stylesheet' && element.href;
              if (linkElementUsingStylesheet) {
                const fetch = typeof frameworkConfiguration.fetch === 'function' ? frameworkConfiguration.fetch : frameworkConfiguration.fetch?.fn;
                stylesheetElement = convertLinkAsStyle(element, (styleElement) => css.process(appWrapper, styleElement, appName), fetch);
                dynamicLinkAttachedInlineStyleMap.set(element, stylesheetElement);
              } else {
                css.process(appWrapper, stylesheetElement, appName);
              }
            }
            const mountDOM = target === 'head' ? getAppWrapperHeadElement(appWrapper) : appWrapper;
            const referenceNode = mountDOM.contains(refChild) ? refChild : null;
            let refNo;
            if (referenceNode) {
              refNo = Array.from(mountDOM.childNodes).indexOf(referenceNode);
            }
            const result = rawDOMAppendOrInsertBefore.call(mountDOM, stylesheetElement, referenceNode);
            if (typeof refNo === 'number' && refNo !== -1) {
              defineNonEnumerableProperty(stylesheetElement, styleElementRefNodeNo, refNo);
            }
            dynamicStyleSheetElements.push(stylesheetElement);
            return result;
          }
          case SCRIPT_TAG_NAME: {
            const { src, text } = element;
            if ((excludeAssetFilter && src && excludeAssetFilter(src)) || !isExecutableScriptType(element)) {
              return rawDOMAppendOrInsertBefore.call(this, element, refChild);
            }
            const appWrapper = appWrapperGetter();
            const mountDOM = target === 'head' ? getAppWrapperHeadElement(appWrapper) : appWrapper;
            const { fetch } = frameworkConfiguration;
            const referenceNode = mountDOM.contains(refChild) ? refChild : null;
            const scopedGlobalVariables = speedySandbox ? cachedGlobals : [];
            if (src) {
              let isRedfinedCurrentScript = false;
              execScripts(null, [src], proxy, {
                fetch,
                strictGlobal,
                scopedGlobalVariables,
                beforeExec: () => {
                  const isCurrentScriptConfigurable = () => {
                    const descriptor = Object.getOwnPropertyDescriptor(document, 'currentScript');
                    return !descriptor || descriptor.configurable;
                  };
                  if (isCurrentScriptConfigurable()) {
                    Object.defineProperty(document, 'currentScript', {
                      get() {
                        return element;
                      },
                      configurable: true
                    });
                    isRedfinedCurrentScript = true;
                  }
                },
                success: () => {
                  manualInvokeElementOnLoad(element);
                  if (isRedfinedCurrentScript) {
                    delete document.currentScript;
                  }
                  element = null;
                },
                error: () => {
                  manualInvokeElementOnError(element);
                  if (isRedfinedCurrentScript) {
                    delete document.currentScript;
                  }
                  element = null;
                }
              });
              const dynamicScriptCommentElement = document.createComment(`dynamic script ${src} replaced by qiankun`);
              dynamicScriptAttachedCommentMap.set(element, dynamicScriptCommentElement);
              return rawDOMAppendOrInsertBefore.call(mountDOM, dynamicScriptCommentElement, referenceNode);
            }
            execScripts(null, [`<script>${text}</script>`], proxy, { strictGlobal, scopedGlobalVariables });
            const dynamicInlineScriptCommentElement = document.createComment('dynamic inline script replaced by qiankun');
            dynamicScriptAttachedCommentMap.set(element, dynamicInlineScriptCommentElement);
            return rawDOMAppendOrInsertBefore.call(mountDOM, dynamicInlineScriptCommentElement, referenceNode);
          }
          default:
            break;
        }
      }
      return rawDOMAppendOrInsertBefore.call(this, element, refChild);
    }
    appendChildOrInsertBefore[overwrittenSymbol] = true;
    return appendChildOrInsertBefore;
  }
  

function getNewRemoveChild(
    rawRemoveChild,
    containerConfigGetter,
    target,
    isInvokedByMicroApp,
) {
    function removeChild(that, child) {
        const { tagName } = child;
        if (!isHijackingTag(tagName) || !isInvokedByMicroApp(child)) return rawRemoveChild.call(that, child);

        try {
            let attachedElement;
            const { appWrapperGetter, dynamicStyleSheetElements } = containerConfigGetter(child);

            switch (tagName) {
                case STYLE_TAG_NAME:
                case LINK_TAG_NAME: {
                    attachedElement = dynamicLinkAttachedInlineStyleMap.get(child) || child;

                    // try to remove the dynamic style sheet
                    const dynamicElementIndex = dynamicStyleSheetElements.indexOf(attachedElement);
                    if (dynamicElementIndex !== -1) {
                        dynamicStyleSheetElements.splice(dynamicElementIndex, 1);
                    }

                    break;
                }

                case SCRIPT_TAG_NAME: {
                    attachedElement = dynamicScriptAttachedCommentMap.get(child) || child;
                    break;
                }

                default: {
                    attachedElement = child;
                }
            }

            const appWrapper = appWrapperGetter();
            const container = target === 'head' ? getAppWrapperHeadElement(appWrapper) : appWrapper;
            // container might have been removed while app unmounting if the removeChild action was async
            if (container.contains(attachedElement)) {
                return rawRemoveChild.call(attachedElement.parentNode, attachedElement);
            }
        } catch (e) {
            console.warn(e);
        }

        return rawRemoveChild.call(that, child);
    }

    removeChild[overwrittenSymbol] = true;
    return removeChild;
}

export function patchHTMLDynamicAppendPrototypeFunctions(
    isInvokedByMicroApp,
    containerConfigGetter,
) {
    const rawHeadAppendChild = HTMLHeadElement.prototype.appendChild;
    const rawBodyAppendChild = HTMLBodyElement.prototype.appendChild;
    const rawHeadInsertBefore = HTMLHeadElement.prototype.insertBefore;

    // Just overwrite it while it have not been overwritten
    if (
        rawHeadAppendChild[overwrittenSymbol] !== true &&
        rawBodyAppendChild[overwrittenSymbol] !== true &&
        rawHeadInsertBefore[overwrittenSymbol] !== true
    ) {
        HTMLHeadElement.prototype.appendChild = getOverwrittenAppendChildOrInsertBefore({
            rawDOMAppendOrInsertBefore: rawHeadAppendChild,
            containerConfigGetter,
            isInvokedByMicroApp,
            target: 'head',
        });
        HTMLBodyElement.prototype.appendChild = getOverwrittenAppendChildOrInsertBefore({
            rawDOMAppendOrInsertBefore: rawBodyAppendChild,
            containerConfigGetter,
            isInvokedByMicroApp,
            target: 'body',
        });

        HTMLHeadElement.prototype.insertBefore = getOverwrittenAppendChildOrInsertBefore({
            rawDOMAppendOrInsertBefore: rawHeadInsertBefore,
            containerConfigGetter,
            isInvokedByMicroApp,
            target: 'head',
        });
    }

    const rawHeadRemoveChild = HTMLHeadElement.prototype.removeChild;
    const rawBodyRemoveChild = HTMLBodyElement.prototype.removeChild;
    // Just overwrite it while it have not been overwritten
    if (rawHeadRemoveChild[overwrittenSymbol] !== true && rawBodyRemoveChild[overwrittenSymbol] !== true) {
        HTMLHeadElement.prototype.removeChild = getNewRemoveChild(
            rawHeadRemoveChild,
            containerConfigGetter,
            'head',
            isInvokedByMicroApp,
        );
        HTMLBodyElement.prototype.removeChild = getNewRemoveChild(
            rawBodyRemoveChild,
            containerConfigGetter,
            'body',
            isInvokedByMicroApp,
        );
    }

    return function unpatch() {
        HTMLHeadElement.prototype.appendChild = rawHeadAppendChild;
        HTMLHeadElement.prototype.removeChild = rawHeadRemoveChild;
        HTMLBodyElement.prototype.appendChild = rawBodyAppendChild;
        HTMLBodyElement.prototype.removeChild = rawBodyRemoveChild;

        HTMLHeadElement.prototype.insertBefore = rawHeadInsertBefore;
    };
}


export function rebuildCSSRules(
    styleSheetElements,
    reAppendElement,
) {
    styleSheetElements.forEach((stylesheetElement) => {
        // re-append the dynamic stylesheet to sub-app container
        const appendSuccess = reAppendElement(stylesheetElement);
        if (appendSuccess) {
            /*
            get the stored css rules from styled-components generated element, and the re-insert rules for them.
            note that we must do that after style element had been added to document, which stylesheet would be associated to the document automatically.
            check the spec https://www.w3.org/TR/cssom-1/#associated-css-style-sheet
             */
            if (stylesheetElement instanceof HTMLStyleElement && isStyledComponentsLike(stylesheetElement)) {
                const cssRules = getStyledElementCSSRules(stylesheetElement);
                if (cssRules) {
                    // eslint-disable-next-line no-plusplus
                    for (let i = 0; i < cssRules.length; i++) {
                        const cssRule = cssRules[i];
                        const cssStyleSheetElement = stylesheetElement.sheet;
                        cssStyleSheetElement.insertRule(cssRule.cssText, cssStyleSheetElement.cssRules.length);
                    }
                }
            }
        }
    });
}